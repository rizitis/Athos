#!/bin/bash
# shellcheck disable=SC2046,SC2086,SC2140,SC1090,SC2034,SC2154

APPL=AthOS


set -e

. /etc/"$APPL"/athos.env

# package name for build
package="$1"

# Check if a package name was provided
if [ -z "$package" ]; then
    echo "Error: No package name provided."
    echo -e "Error: Invalid command.\nUsage:\n  athos package_name        # To build an existing package\n  athos package_name mkbuild # To create a new package build template\n  athos package_name mkedit # To edit package ini file\n  athos package_name mklog # To view PackageBuild.log"
    exit 1
fi

# If only $1 (package name) is provided, source the .ini file
if [ -z "$2" ]; then
    # Source the .ini file to load configuration and build instructions
    if [ -f "$W_DIR"/"$package"/"$package".ini ]; then
        source "$W_DIR"/"$package"/"$package".ini
    else
        echo "Error: Build file '$W_DIR/$package/$package.ini' not found."
        exit 1
    fi
elif [ "$2" = "mkbuild" ]; then
    # If $2 is 'mkbuild', create the package directory and template build file
    echo "Creating new project for $package..."
    mkdir -p "$W_DIR"/"$package"
    cd "$A_HOME" || exit
    cp "$W_DIR"/"$package"/"$package".ini "$W_DIR"/"$package"/"$package".ini.bak || true
    cat /usr/share/"$APPL"/TEMPLATES/TEMPLATE.ini > "$W_DIR"/"$package"/"$package".ini
    echo "Created new project $package/$package.ini"
    ls "$W_DIR"/"$package"
    exit 0
elif [ "$2" = "mkedit" ]; then
    # open default text editor to edit ini
    xdg-open "$W_DIR"/"$package"/"$package".ini &
    exit
elif [ "$2" = "mklog" ]; then
    xdg-open /tmp/"$package"-build.log &
    exit
elif [ "$2" = "mkopen-dir" ]; then
    # open default file manager folder
    xdg-open "$W_DIR"/"$package" &
    exit
elif [ "$2" = "mkcat" ]; then
    # open default file manager folder
    cat "$W_DIR"/"$package"/"$package".ini &
    exit
else
    echo -e "Error: Invalid command.\nUsage:\n  athos package_name        # To build an existing package\n    athos package_name mkbuild        # To create a new package build template\n     athos package_name mkedit        # To edit package ini file\n      athos package_name mklog        # To view PackageBuild.log\n   athos packane_name mkopen-dir        # To open package folder"
    exit 1
fi

# we unset it for now but set it again later before we call build functions and start building.
set +e

cd "$W_DIR"/"$package" || exit 1
CWD=$(pwd)
DATE="$(date)"
# Setup build log file
LOGFILE=/tmp/"$package"-build.log
# shellcheck disable=SC2086
rm $LOGFILE || true
exec > >(tee -a "$LOGFILE") 2>&1

JOBS=${JOBS:-"-j$(getconf _NPROCESSORS_ONLN)"}
# This is for slackdesk app. If not installed then a slack-desc must exist in package folder as usually.
mkdesc="$(which slackdesc)" || true

echo "Starting build process..."
start_time=$(date +%s)

# This is only for developers not used in generally but i need it here...
DEV=
PRJ=
AUTO_UPD=$(curl --silent -L "https://api.github.com/repos/$DEV/$PRJ/releases/latest" | jq -r '.tag_name' | sed 's/^v//')

# I like the old tlz but you can change this to tgz or txz...
PKGTYPE=${PKGTYPE:-tlz}
PKG="$CWD"/package-$PRGNAM
TMP="$CWD"/work
OUTPUT=/tmp/"$PRGNAM"

# Detect the architecture if not already set
if [ -z "$ARCH" ]; then
case "$(uname -m)" in
 i386) ARCH=i586 ;;          # 32-bit Intel architecture
 i686) ARCH=i686 ;;          # 32-bit Intel architecture (optimized)
 x86_64) ARCH=x86_64 ;;      # 64-bit Intel architecture
 armv7* | armhf) ARCH=armv7 ;;  # ARMv7 (32-bit, hardware float)
 armv6* | armv5*) ARCH=armv6 ;;  # ARMv6 (32-bit)
 aarch64 | arm64) ARCH=aarch64 ;;  # ARMv8 (64-bit)
 ppc | ppc64) ARCH=ppc ;;     # PowerPC (32-bit or 64-bit)
 s390x) ARCH=s390x ;;        # IBM System Z (64-bit)
 mips*) ARCH=mips ;;         # MIPS (various variants)
 riscv64) ARCH=riscv64 ;;    # RISC-V 64-bit
 sparc64) ARCH=sparc64 ;;     # SPARC (64-bit)
 *)
   echo "Error: Unsupported architecture '$(uname -m)'. Exiting."
   exit 1
   ;;
esac
fi

echo "Detected architecture: $ARCH"

# Output package name if required
# shellcheck disable=SC2236
if [ ! -z "${PRINT_PACKAGE_NAME}" ]; then
echo "${PRGNAM}-${VERSION}-${ARCH}-${BUILD}${TAG}.${PKGTYPE}"
exit 0
fi

# Check if ARCH is set (redundant here, but kept for safety)
if [ -z "$ARCH" ]; then
echo "Error: ARCH variable is not set. Please set it to the target architecture."
exit 1
fi

# Set compiler flags based on architecture for musl/GCC
case "$ARCH" in
"i586")
 SLKCFLAGS="-O2 -march=i586 -mtune=i686"
 LIBDIRSUFFIX=""
 QMAKE_CFLAGS="-O2 -m32 -march=i586 -mtune=i686"
 QMAKE_CXXFLAGS="-O2 -m32 -march=i586 -mtune=i686"
 QMAKE_LFLAGS="-L/usr/lib -L/usr/local/lib"
 ;;

"i686")
 SLKCFLAGS="-O2 -march=i686 -mtune=i686"
 LIBDIRSUFFIX=""
 QMAKE_CFLAGS="-O2 -m32 -march=i686 -mtune=i686"
 QMAKE_CXXFLAGS="-O2 -m32 -march=i686 -mtune=i686"
 QMAKE_LFLAGS="-L/usr/lib -L/usr/local/lib"
 ;;

"x86_64")
 SLKCFLAGS="-O2 -march=x86-64 -mtune=generic -fPIC"
 LIBDIRSUFFIX="64"
 QMAKE_CFLAGS="-O2 -m64 -march=x86-64 -mtune=generic -fPIC"
 QMAKE_CXXFLAGS="-O2 -m64 -march=x86-64 -mtune=generic -fPIC"
 QMAKE_LFLAGS="-L/usr/lib64 -L/usr/local/lib64"
 ;;

"armv7")
 SLKCFLAGS="-O2 -march=armv7-a -mtune=generic -fPIC"
 LIBDIRSUFFIX=""
 QMAKE_CFLAGS="-O2 -m32 -march=armv7-a -mtune=generic -fPIC"
 QMAKE_CXXFLAGS="-O2 -m32 -march=armv7-a -mtune=generic -fPIC"
 QMAKE_LFLAGS="-L/usr/lib -L/usr/local/lib"
 ;;

"armv6")
 SLKCFLAGS="-O2 -march=armv6 -mtune=generic -fPIC"
 LIBDIRSUFFIX=""
 QMAKE_CFLAGS="-O2 -m32 -march=armv6 -mtune=generic -fPIC"
 QMAKE_CXXFLAGS="-O2 -m32 -march=armv6 -mtune=generic -fPIC"
 QMAKE_LFLAGS="-L/usr/lib -L/usr/local/lib"
 ;;

"aarch64")
 SLKCFLAGS="-O2 -march=armv8-a -mtune=generic -fPIC"
 LIBDIRSUFFIX="64"
 QMAKE_CFLAGS="-O2 -march=armv8-a -mtune=generic -fPIC"
 QMAKE_CXXFLAGS="-O2 -march=armv8-a -mtune=generic -fPIC"
 QMAKE_LFLAGS="-L/usr/lib64 -L/usr/local/lib64"
 ;;

"ppc")
 SLKCFLAGS="-O2 -mppc"
 LIBDIRSUFFIX=""
 QMAKE_CFLAGS="-O2 -m32 -mppc"
 QMAKE_CXXFLAGS="-O2 -m32 -mppc"
 QMAKE_LFLAGS="-L/usr/lib -L/usr/local/lib"
 ;;

"ppc64")
 SLKCFLAGS="-O2 -mppc64"
 LIBDIRSUFFIX="64"
 QMAKE_CFLAGS="-O2 -m64 -mppc64"
 QMAKE_CXXFLAGS="-O2 -m64 -mppc64"
 QMAKE_LFLAGS="-L/usr/lib64 -L/usr/local/lib64"
 ;;

"s390x")
 SLKCFLAGS="-O2 -march=s390x"
 LIBDIRSUFFIX="64"
 QMAKE_CFLAGS="-O2 -m64 -march=s390x"
 QMAKE_CXXFLAGS="-O2 -m64 -march=s390x"
 QMAKE_LFLAGS="-L/usr/lib64 -L/usr/local/lib64"
 ;;

"mips")
 SLKCFLAGS="-O2 -march=mips32"
 LIBDIRSUFFIX=""
 QMAKE_CFLAGS="-O2 -m32 -march=mips32"
 QMAKE_CXXFLAGS="-O2 -m32 -march=mips32"
 QMAKE_LFLAGS="-L/usr/lib -L/usr/local/lib"
 ;;

"riscv64")
 SLKCFLAGS="-O2 -march=rv64imac -mabi=lp64"
 LIBDIRSUFFIX="64"
 QMAKE_CFLAGS="-O2 -m64 -march=rv64imac -mabi=lp64"
 QMAKE_CXXFLAGS="-O2 -m64 -march=rv64imac -mabi=lp64"
 QMAKE_LFLAGS="-L/usr/lib64 -L/usr/local/lib64"
 ;;

"sparc64")
 SLKCFLAGS="-O2 -m64"
 LIBDIRSUFFIX="64"
 QMAKE_CFLAGS="-O2 -m64"
 QMAKE_CXXFLAGS="-O2 -m64"
 QMAKE_LFLAGS="-L/usr/lib64 -L/usr/local/lib64"
 ;;

*)
 echo "Warning: Unsupported architecture '$ARCH'. Using generic flags."
 SLKCFLAGS="-O2"
 LIBDIRSUFFIX=""
 QMAKE_CFLAGS="-O2"
 QMAKE_CXXFLAGS="-O2"
 QMAKE_LFLAGS="-L/usr/lib"
 ;;
esac

# Check for required deps pkg.ini, scan system if installed if not try to find them in $W_DIR for build install.
check_deps() {
    if [ -n "$REQUIRED" ]; then
        echo "Required dependencies: $REQUIRED"

        for buildpkg in $REQUIRED; do
            if ! find /var/lib/pkgtools/packages -maxdepth 1 -name "${buildpkg}-[0-9]*" | grep -q .; then
                echo "Building dep $buildpkg..."
                athos "$buildpkg"
            else
                echo "$buildpkg is already installed!"
            fi
        done
    else
        echo "No required dependencies specified."
    fi
}
# The same as check_deps but for optional deps first ask to build install or not...
opt_deps() {
    if [ -n "$OPTDEPS" ]; then
        echo "Found optional dependencies: $OPTDEPS"
        read -p "Should check and build optional deps if not installed? (yes/no): " answer
        answer=$(echo "$answer" | tr '[:upper:]' '[:lower:]')

        if [[ "$answer" =~ ^(yes|y)$ ]]; then
            # Handle both array and string definitions of OPTDEPS
            for buildopt in $OPTDEPS; do
                if ! find /var/adm/packages -maxdepth 1 -name "${buildopt}-[0-9]*" | grep -q .; then
                    echo "Building optional dep $buildopt..."
                    athos "$buildopt"
                else
                    echo "$buildopt is already installed!"
                fi
            done
        elif [[ "$answer" =~ ^(no|n)$ ]]; then
            echo "You answered no."
        else
            echo "Invalid response. I will take that as NO."
        fi
    else
        echo "No optional dependencies found."
    fi
}


# After slackbuild finish create docs , slackdesk, doinst etc...
after_build(){
if [[ $COMPRESS != "rpm" && $COMPRESS != "deb" ]]; then
	  mkdir -p "$PKG"/usr/doc/$PRGNAM-"$VERSION"

# files...
cp  AUTHORS ChangeLog* COPYING CREDITS LICENSE MAINTAINERS NEWS README* "$PKG/usr/doc/$PRGNAM-$VERSION/" || true
#find . -maxdepth 1 -type f -exec cp -a {} "$PKG/usr/doc/$PRGNAM-$VERSION/" \;


# Iterate over directories in the current directory and copy them
cp -R docs DOCS "$PKG/usr/doc/$PRGNAM-$VERSION/" || true
#find . -maxdepth 1 -type d ! -name . -exec cp -R {} "$PKG/usr/doc/$PRGNAM-$VERSION/" \;


cat "$CWD"/$PRGNAM.ini > "$PKG"/usr/doc/$PRGNAM-"$VERSION"/$PRGNAM.ini
	  find "$PKG"/usr/doc/$PRGNAM-"$VERSION" -type f -exec chmod 644 {} \;

	  mkdir -p "$PKG"/install
     if [ -f "$CWD"/doinst.sh ]; then
	  cat "$CWD"/doinst.sh >> "$PKG"/install/doinst.sh
	elif [ -f "$CWD"/doinst.sh.gz ]; then
	  zcat "$CWD"/doinst.sh.gz >> "$PKG"/install/doinst.sh
	else

cat <<MKINS >> "$PKG"/install/doinst.sh
     config() {
       for infile in \$1; do
         NEW="\$infile"
         OLD="\$(dirname \$NEW)/\$(basename \$NEW .new)"
         if [ ! -r \$OLD ]; then
           mv \$NEW \$OLD
         elif [ "\$(cat \$OLD | md5sum)" = "\$(cat \$NEW | md5sum)" ]; then
         rm \$NEW
         fi
         done
        }

     preserve_perms() {
       NEW="\$1"
       OLD="\$(dirname \$NEW)/\$(basename \$NEW .new)"
       if [ -e \$OLD ]; then
         cp -a \$OLD \${NEW}.incoming
         cat \$NEW > \${NEW}.incoming
         mv \${NEW}.incoming \$NEW
       fi
       config \$NEW
       }


#        preserve_perms etc/rc.d/rc.INIT.new
#        config etc/configfile.new

     if [ -x /usr/bin/fc-cache ]; then
       /usr/bin/fc-cache -fv /usr/share/fonts/
     fi

     if [ -x usr/bin/update-desktop-database ]; then
       chroot . /usr/bin/update-desktop-database usr/share/applications > /dev/null 2>&1
     fi

     if [ -d usr/share/icons/hicolor ]; then
       if [ -x /usr/bin/gtk-update-icon-cache ]; then
         chroot . /usr/bin/gtk-update-icon-cache -f -t usr/share/icons/hicolor 1> /dev/null 2> /dev/null
       fi
     fi

     if [ -e usr/share/glib-2.0/schemas ]; then
       if [ -x /usr/bin/glib-compile-schemas ]; then
         /usr/bin/glib-compile-schemas usr/share/glib-2.0/schemas >/dev/null 2>&1
       fi
     fi

     if [ -x usr/bin/update-mime-database ]; then
       chroot . /usr/bin/update-mime-database usr/share/mime >/dev/null 2>&1
     fi

MKINS
fi
	if [ -f "$CWD"/slack-desc ]; then
	  cat "$CWD"/slack-desc > "$PKG"/install/slack-desc
	 elif [ -x "$mkdesc" ]; then
	  $mkdesc "$PRGNAM" "$SortDesc" "$LongDesc" "$Homepage" > "$PKG"/install/slack-desc
	 else
	  echo " "
	  echo "Not slack-desc found or created   :-("
	  echo "You must have a slack-desc in $CWD"
	  echo "Or you must create one. Please read lines: 25-33 of $PRGNAM.ini"
	  echo " "
	  exit 1
	fi

	if [ -f "$CWD"/slack-required ]; then
	  cat "$CWD"/slack-required > "$PKG"/install/slack-required
	fi

	if [ -f "$CWD"/slack-suggests ]; then
	  cat "$CWD"/slack-suggests > "$PKG"/install/slack-suggests
	  cat "$CWD"/slack-suggests > "$PKG"/usr/doc/"$PRGNAM-$VERSION"/slack-suggests
	fi

	if [ -f "$CWD"/slack-conflicts ]; then
	  cat "$CWD"/slack-conflicts > "$PKG"/install/slack-conflicts
	  cat "$CWD"/slack-conflicts > "$PKG"/usr/doc/"$PRGNAM-$VERSION"/slack-conflicts
	fi

	if [ -d "$PKG"/usr/man ]; then
	  ( cd "$PKG"/usr/man
	  find . -type f -exec gzip -9 {} \;
	  # shellcheck disable=SC2044
	  # shellcheck disable=SC2046
	  for i in $(find . -type l) ; do ln -s $(readlink "$i").gz "$i".gz ; rm "$i" ; done
	  )
	fi

	if [ -d "$PKG"/usr/info ]; then
	  gzip -9 "$PKG"/usr/info/*.info
	  rm -f "$PKG"/usr/info/dir
	fi
else
mkdir -p "$PKG"/usr/doc/"$PRGNAM"-"$VERSION"
mv "$PKG"/usr/share/doc/"$PRGNAM" "$PKG"/usr/doc/"$PRGNAM"-"$VERSION"/ || true
mv "$PKG"/usr/share/{licenses,LICENSE} "$PKG"/usr/doc/"$PRGNAM"-"$VERSION"/ || true
cat "$CWD"/"$PRGNAM".ini > "$PKG"/usr/doc/"$PRGNAM"-"$VERSION"/"$PRGNAM".ini
	  find "$PKG"/usr/doc/"$PRGNAM"-"$VERSION" -type f -exec chmod 644 {} \;

	  mkdir -p "$PKG"/install
  if [ -f "$CWD"/doinst.sh ]; then
	  cat "$CWD"/doinst.sh >> "$PKG"/install/doinst.sh
	elif [ -f "$CWD"/doinst.sh.gz ]; then
	  zcat "$CWD"/doinst.sh.gz >> "$PKG"/install/doinst.sh
	else

cat <<MKINS >> "$PKG"/install/doinst.sh
  config() {
    for infile in \$1; do
      NEW="\$infile"
      OLD="\$(dirname \$NEW)/\$(basename \$NEW .new)"
      if [ ! -r \$OLD ]; then
        mv \$NEW \$OLD
      elif [ "\$(cat \$OLD | md5sum)" = "\$(cat \$NEW | md5sum)" ]; then
      rm \$NEW
      fi
      done
     }

  preserve_perms() {
    NEW="\$1"
    OLD="\$(dirname \$NEW)/\$(basename \$NEW .new)"
    if [ -e \$OLD ]; then
      cp -a \$OLD \${NEW}.incoming
      cat \$NEW > \${NEW}.incoming
      mv \${NEW}.incoming \$NEW
    fi
    config \$NEW
    }


#   preserve_perms etc/rc.d/rc.INIT.new
#   config etc/configfile.new

  if [ -x /usr/bin/fc-cache ]; then
    /usr/bin/fc-cache -fv /usr/share/fonts/
  fi

  if [ -x usr/bin/update-desktop-database ]; then
    chroot . /usr/bin/update-desktop-database usr/share/applications > /dev/null 2>&1
  fi

  if [ -d usr/share/icons/hicolor ]; then
    if [ -x /usr/bin/gtk-update-icon-cache ]; then
      chroot . /usr/bin/gtk-update-icon-cache -f -t usr/share/icons/hicolor 1> /dev/null 2> /dev/null
    fi
  fi

  if [ -e usr/share/glib-2.0/schemas ]; then
    if [ -x /usr/bin/glib-compile-schemas ]; then
      /usr/bin/glib-compile-schemas usr/share/glib-2.0/schemas >/dev/null 2>&1
    fi
  fi

  if [ -x usr/bin/update-mime-database ]; then
    chroot . /usr/bin/update-mime-database usr/share/mime >/dev/null 2>&1
  fi

MKINS
fi
	if [ -f "$CWD"/slack-desc ]; then
	  cat "$CWD"/slack-desc > "$PKG"/install/slack-desc
	 elif [ -x "$mkdesc" ]; then
	  $mkdesc "$PRGNAM" "$SortDesc" "$LongDesc" "$Homepage" > "$PKG"/install/slack-desc
	 else
	  echo " "
	  echo "Not slackdesc app found or created   :-("
	  echo "You must have slackdesc app installed"
	  echo "Or you must create a slack-desc in next to $PRGNAM.ini"
	  echo " "
	  exit 1
	fi

	if [ -f "$CWD"/slack-required ]; then
	  cat "$CWD"/slack-required > "$PKG"/install/slack-required
	fi

	if [ -f "$CWD"/slack-suggests ]; then
	  cat "$CWD"/slack-suggests > "$PKG"/install/slack-suggests
	  cat "$CWD"/slack-suggests > "$PKG"/usr/doc/"$PRGNAM-$VERSION"/slack-suggests
	fi

	if [ -f "$CWD"/slack-conflicts ]; then
	  cat "$CWD"/slack-conflicts > "$PKG"/install/slack-conflicts
	  cat "$CWD"/slack-conflicts > "$PKG"/usr/doc/"$PRGNAM-$VERSION"/slack-conflicts
	fi
fi
}


# after slackbuild function finish, remove la files , prellocal.pod etc... then call makepkg and remove rpaths if needed before create binary on /tmp/
package_build() {
cd "$PKG" || exit 66
	  rm -f "$PKG"/{,usr/}lib${LIBDIRSUFFIX}/*.la
       rm -f "$PKG"/usr/lib/*.la || true
       rm -f "$PKG"/lib/*.la || true
	  # shellcheck disable=SC2038
	  find "$PKG" | xargs file | grep -e "executable" -e "shared object" | grep ELF \
	  | cut -f 1 -d : | xargs strip --strip-unneeded 2> /dev/null || true

	  # shellcheck disable=SC2038
	  find "$PKG" -name perllocal.pod \
	  -o -name ".packlist" \
	  -o -name "*.bs" \
	  | xargs rm -f

	  cd "$PKG" || exit
# add sudo here in case you build as user , else makepkg stop...
sudo  makepkg --remove-rpaths -l y -c n "$OUTPUT"/$PRGNAM-"$VERSION"-"$ARCH"-"$BUILD""$TAG"."$PKGTYPE" 2>&1 | tee "$OUTPUT"/makepkg-${PRGNAM}.log
	  echo "$DATE $Packager" | sed -e '1r /dev/stdin' "$OUTPUT/makepkg-${PRGNAM}.log" > "$OUTPUT/makepkg-${PRGNAM}.log.tmp" && mv "$OUTPUT/makepkg-${PRGNAM}.log.tmp" "$OUTPUT/makepkg-${PRGNAM}.log"


	  cd "$OUTPUT" || exit
	  md5sum $PRGNAM-"$VERSION"-"$ARCH"-"$BUILD""$TAG"."$PKGTYPE" > $PRGNAM-"$VERSION"-"$ARCH"-"$BUILD""$TAG"."$PKGTYPE".md5
	  # shellcheck disable=SC2002
	  cat "$PKG"/install/slack-desc | grep "^${PRGNAM}" > $PRGNAM-"$VERSION"-"$ARCH"-"$BUILD""$TAG"."$PKGTYPE".txt
	  cat $PRGNAM-"$VERSION"-"$ARCH"-"$BUILD""$TAG"."$PKGTYPE".txt > README
	if [ -f "$PKG"/install/slack-required ]; then
	  # shellcheck disable=SC2086
	  cat "$PKG"/install/slack-required > $PRGNAM-$VERSION-"$ARCH"-"$BUILD""$TAG".dep
	fi
}

# clean all src files and working Dirs.
clean_src(){
	cd "$CWD" || exit
if [[ "$COMPRESS" == "git" ]]; then
sudo	rm -r package-"$PRGNAM" work
else
# shellcheck disable=SC2035
sudo rm -r package-"$PRGNAM" work *.$COMPRESS *.tar.?z* || true
fi
}


# Install the output or upgrade.
pkg_install(){
sudo upgradepkg --install-new --reinstall "$OUTPUT"/$PRGNAM-"$VERSION"-"$ARCH"-"$BUILD""$TAG"."$PKGTYPE"
}


# Not used its for developers only... but its ok to be here for all.
sig_package(){
#  Add you id_rsa, example:
 prikey_path="/root/id_rsa"
      openssl dgst -sha256 -sign $prikey_path  -out "$OUTPUT"/$PRGNAM-"$VERSION"-"$ARCH"-"$BUILD""$TAG"."$PKGTYPE".sig "$OUTPUT"/$PRGNAM-"$VERSION"-"$ARCH"-"$BUILD""$TAG"."$PKGTYPE"
}


download_src() {
if [[ $AGENT == ON ]]; then
# Use eval to construct and run the download command
 DOWNLOAD_AGENT
else
if [[ "$VERSION" != "$AUTO_UPD" ]]; then
 sleep 1
 if [[ $COMPRESS == "git" ]]; then
   GIT="$(which git)"
   $GIT clone "$SRCURL"
   if [[ -n "$GITCHEK" ]]; then
     cd "$SRCNAM" || cd "$PRGNAM" || exit
     $GIT checkout "$GITCHEK"
   fi
 elif [[ $COMPRESS == "svn" ]]; then
   SVN="$(which svn)"
   $SVN co "$SRCURL"
 elif [[ $COMPRESS == "cvs" ]]; then
   CVS="$(which cvs)"
   $CVS -z3 -f "$SRCURL"
 elif [[ $COMPRESS == "lftp" ]]; then
   LFTP="$(which lftp)"
   $LFTP -c mirror "$SRCURL"
 elif [[ $COMPRESS == "deb" ]]; then
   wget -c $SRCURL
 elif [[ $COMPRESS == "rpm" ]]; then
   wget -c $SRCURL
 elif [[ $COMPRESS == "snap" ]]; then
   wget -c $SRCURL
 else
   wget -O "$SRCNAM"-"$VERSION"."$COMPRESS" "$SRCURL"
 fi
elif [[ "$VERSION" == "$AUTO_UPD" ]]; then
 # If the release version is "null", fall back to fetching from tags
 if [[ "$VERSION" == "null" || -z "$VERSION" ]]; then
   # Get the latest tag if release is not available
   VERSION=$(curl --silent -L "https://api.github.com/repos/$DEV/$PRJ/tags" | jq -r '.[0].name' | sed 's/^v//')
   echo "Falling back to latest tag: $VERSION"
   wget -c https://github.com/"$DEV"/"$PRJ"/archive/v"$VERSION"/"$SRCNAM"-"$VERSION"."$COMPRESS"
 else
 echo "Latest release version: $VERSION"
   wget -c https://github.com/"$DEV"/"$PRJ"/releases/download/"$VERSION"/"$SRCNAM"-"$VERSION"."$COMPRESS" || wget -O "$SRCNAM"-"$VERSION"."$COMPRESS" https://github.com/"$DEV"/"$PRJ"/archive/refs/tags/"$VERSION"."$COMPRESS"
 fi
else
 echo "Download_src Messed up $VERSION"
 exit 8
fi
fi

# Possible filenames to check
possible_files=(
"$PRGNAM-$VERSION.$COMPRESS"
"$SRCNAM-$VERSION.$COMPRESS"
"$PRGNAM.$COMPRESS"
"$SRCNAM.$COMPRESS"
"$PRGNAM"
"$SRCNAM"
)

# Check if MDSCHK is provided
if [ -n "$MDSCHK" ]; then
# MDSCHK is not empty, so proceed with checksum verification

# Search for the first existing file
found_file=""
for file in "${possible_files[@]}"; do
 if [[ -f "$file" ]]; then
   found_file="$file"
   break  # Stop as soon as we find an existing file
 fi
done

# If a file was found, check its checksum
if [[ -n "$found_file" ]]; then
 echo "Found file: $found_file. Checking MD5 checksum..."
 if echo "$MDSCHK  $found_file" | md5sum -c -; then
   echo "Checksum matches for $found_file. Proceeding..."
 else
   echo "Checksum verification failed for $found_file. Preparing to re-download."
   # Delete all possible files and re-download if checksum fails or no file found
echo "Deleting existing files and re-downloading..."
for file in "${possible_files[@]}"; do
 rm -rf "$file"
done
download_src
 fi
else
 echo "No file found to verify. Proceeding to re-download."
 # Delete all possible files and re-download if checksum fails or no file found
echo "Deleting existing files and re-downloading..."
for file in "${possible_files[@]}"; do
 rm -rf "$file"
download_src
done
fi
else
# MDSCHK is empty, so we skip checksum verification and proceed without re-downloading
echo "No MDSCHK provided. Skipping checksum verification and proceeding without re-downloading."
fi
}

# chroot for build package
chrooting(){
	chown -R root:root .
	find -L . \
	  \( -perm 777 -o -perm 775 -o -perm 750 -o -perm 711 -o -perm 555 \
	  -o -perm 511 \) -exec chmod 755 {} \; -o \
	  \( -perm 666 -o -perm 664 -o -perm 640 -o -perm 600 -o -perm 444 \
	  -o -perm 440 -o -perm 400 \) -exec chmod 644 {} \;
}



# Prepare the build system and extract source code in work dir or directly in $PKG if needed...
prepare_build(){
set -e
	rm -rf "$PKG" "$OUTPUT" "$COMPRESS"
	mkdir -p "$TMP" "$PKG" "$OUTPUT"
	rm -rf "$TMP"/$PRGNAM-"$VERSION"
set +e
	get_out() {
 if [ -f "$1" ] ; then
     case "$1" in
         *.tar.bz2)  tar xvjf "$1" ;;
         *.tar.gz)   tar xvzf "$1" ;;
         *.tar.xz)   tar xvJf "$1" ;;
         *.bz2)      bunzip2 "$1"  ;;
         *.rar)      rar x "$1"    ;;
         *.gz)       gunzip "$1"   ;;
         *.tar)      tar xvf "$1"  ;;
         *.tbz2)     tar xvjf "$1" ;;
         *.tgz)      tar xvzf "$1" ;;
         *.zip)      unzip "$1"    ;;
         *.Z)        uncompress "$1" ;;
         *.7z)       7z x "$1"     ;;
         *)          echo "Error: Don't know how to extract '$1'." ;;
     esac
 elif [ -n "$SRCNAM" ] && [ -n "$VERSION" ] && [ -f "$SRCNAM-$VERSION" ]; then
     case "$SRCNAM-$VERSION" in
         *.tar.bz2)  tar xvjf "$SRCNAM-$VERSION" ;;
         *.tar.gz)   tar xvzf "$SRCNAM-$VERSION" ;;
         *.tar.xz)   tar xvJf "$SRCNAM-$VERSION" ;;
         *.bz2)      bunzip2 "$SRCNAM-$VERSION"  ;;
         *.rar)      rar x "$SRCNAM-$VERSION"    ;;
         *.gz)       gunzip "$SRCNAM-$VERSION"   ;;
         *.tar)      tar xvf "$SRCNAM-$VERSION"  ;;
         *.tbz2)     tar xvjf "$SRCNAM-$VERSION" ;;
         *.tgz)      tar xvzf "$SRCNAM-$VERSION" ;;
         *.zip)      unzip "$SRCNAM-$VERSION"    ;;
         *.Z)        uncompress "$SRCNAM-$VERSION" ;;
         *.7z)       7z x "$SRCNAM-$VERSION"     ;;
         *)          echo "Error: Don't know how to extract '$SRCNAM-$VERSION'." ;;
     esac
 else
     echo "Error: '$1' is not a valid file!"
 fi

 if [[ ! -e "$CWD/README" && ! -e "$CWD/README.md" ]]; then
   # If neither file exists, create README
   echo "Creating README in: $CWD"
   # shellcheck disable=SC2188
   > "$CWD/README"
   echo "$PRGNAM $SortDesc" > "$CWD/README"
   echo "$PRGNAM $LongDesc" >> "$CWD/README"
 else
 pwd
   echo "README or README.md already exists, skipping creation."
 fi
}


cd "$TMP" || exit
if [[ $COMPRESS != "git" && $COMPRESS != "svn" && $COMPRESS != "cvs" && $COMPRESS != "lftp" && $COMPRESS != "rpm" && $COMPRESS != "deb" && $COMPRESS != "AppImage" && $COMPRESS != "snap" ]]; then
get_out "$CWD"/"$SRCNAM"-"$VERSION"."$COMPRESS" || get_out "$CWD"/"$SRCNAM"."$COMPRESS" || exit
if [[ $BIN_PKG != "YES" ]]; then
  cd $SRCNAM-"$VERSION" || cd $PRGNAM-"$VERSION" || cd $SRCNAM || exit
 else
  echo "BIN_PKG = $BIN_PKG"
fi
echo "hm...lets continue and see what happens"
else
if [[ $COMPRESS = "deb" ]]; then
 cd "$CWD"
 ar x $SRCNAM.$COMPRESS
	rm debian-binary control.tar.?z
	tar -xJf data.tar.?z -C "$PKG"
elif
 [[ $COMPRESS == "AppImage" ]]; then
 echo "$COMPRESS="AppImage""
 mv "$CWD"/"$SRCNAM" "$TMP"
elif
 [[ $COMPRESS == "snap" ]]; then
 echo "COMPRESS="snap""
 unsquashfs -d "$TMP" "$CWD"/"$SRCNAM"."$COMPRESS"
 cd  "$TMP" || exit
elif
 [[ $COMPRESS = "rpm" ]]; then
 cd "$CWD"
 rpm -Kv "$SRCNAM.$COMPRESS"
 rpm2cpio "$SRCNAM"."$COMPRESS" > "$TMP"/"$SRCNAM"."$COMPRESS".cpio
else
mv "$CWD"/"$SRCNAM" "$TMP"
cd $SRCNAM || cd $PRGNAM ||exit
fi
fi
}

write_deps() {
# If you have ready slack-required files for every package just make your life easyer here...
# But some day you must discribe deps in ini file also... :D
INPUT_FILE="$CWD"/"$PRGNAM".info
OUTPUT_FILE="$PKG"/usr/doc/"$PRGNAM-$VERSION"/slack-required
mkdir -p "$PKG"/usr/doc/"$PRGNAM-$VERSION"
touch "$OUTPUT_FILE"
if [ -f "$CWD/slack-required" ]; then
    # If the file "slack-required" exists, copy its content to OUTPUT_FILE
    cat "$CWD/slack-required" > "$OUTPUT_FILE"
    sudo cat "$CWD/slack-required" > "$OUTPUT"/"$PRGNAM".dep
else
    # Process REQUIRES= line if it exists in INPUT_FILE
    if grep -q "^REQUIRES=" "$INPUT_FILE"; then
        grep "^REQUIRES=" $CWD/$PRGNAM.info | sed 's/^REQUIRES="//;s/"$//' | tr ' ' '\n' > "$OUTPUT_FILE"
        sudo grep "^REQUIRES=" $CWD/$PRGNAM.info | sed 's/^REQUIRES="//;s/"$//' | tr ' ' '\n' > "$OUTPUT"/"$PRGNAM".dep
    else
        # Process REQUIRED= line from athos ini file.
        for i in $REQUIRED; do
            echo "$i"
            echo "$i" >> "$OUTPUT_FILE"
            touch "$OUTPUT"/"$PRGNAM".dep
            echo "$i" >> "$OUTPUT"/"$PRGNAM".dep
        done
    fi
fi
}

apk_help() {
cd "$OUTPUT" || exit
echo "$PRGNAM-$VERSION-$ARCH-$BUILD$TAG.$PKGTYPE" > BIN_NAME
}

compress_all() {
pushd "$OUTPUT" || exit
cd .. || exit
tar --use-compress-program=lz4 -cf "$PRGNAM".tar.lz4 "$PRGNAM"
sha256sum "$PRGNAM".tar.lz4 > "$PRGNAM".sha256sum
popd
}
# Main athos build functions.
#set -e


check_deps
opt_deps
download_src
prepare_build
patch_build
if [[ $COMPRESS == snap ]]; then
echo "no chroot for $COMPRESS"
elif [[ $CHROOT == NO ]]; then
if [ "$EUID" -eq 0 ]; then
    echo "You are root. You cant skip chroot when you build as root."
    echo "Either build with chroot or run athos as reqular user if use 'CHROOT == NO'"
    echo "Exiting..."
    exit 1
fi
echo "chroot = $CHROOT skip chrooting..."
else
chrooting
fi
set -e
slackbuild

after_build

write_deps

package_build

apk_help

compress_all

pkg_install
#sig_package
clean_src


# Calculate and display build time
end_time=$(date +%s)
elapsed_time=$((end_time - start_time))
echo "Build process completed in $((elapsed_time / 60)) minutes and $((elapsed_time % 60)) seconds."
chmod -R 775 "$W_DIR"/"$package"
